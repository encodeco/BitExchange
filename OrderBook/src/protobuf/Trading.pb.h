// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Trading.proto

#ifndef PROTOBUF_INCLUDED_Trading_2eproto
#define PROTOBUF_INCLUDED_Trading_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Trading_2eproto 

namespace protobuf_Trading_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Trading_2eproto
namespace be {
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class NumSteps;
class NumStepsDefaultTypeInternal;
extern NumStepsDefaultTypeInternal _NumSteps_default_instance_;
class Order;
class OrderDefaultTypeInternal;
extern OrderDefaultTypeInternal _Order_default_instance_;
class OrderBook;
class OrderBookDefaultTypeInternal;
extern OrderBookDefaultTypeInternal _OrderBook_default_instance_;
class OrderBookList;
class OrderBookListDefaultTypeInternal;
extern OrderBookListDefaultTypeInternal _OrderBookList_default_instance_;
class OrderList;
class OrderListDefaultTypeInternal;
extern OrderListDefaultTypeInternal _OrderList_default_instance_;
class OrderTree;
class OrderTreeDefaultTypeInternal;
extern OrderTreeDefaultTypeInternal _OrderTree_default_instance_;
class OrderTree_OrderMapEntry_DoNotUse;
class OrderTree_OrderMapEntry_DoNotUseDefaultTypeInternal;
extern OrderTree_OrderMapEntry_DoNotUseDefaultTypeInternal _OrderTree_OrderMapEntry_DoNotUse_default_instance_;
class OrderTree_PriceMapEntry_DoNotUse;
class OrderTree_PriceMapEntry_DoNotUseDefaultTypeInternal;
extern OrderTree_PriceMapEntry_DoNotUseDefaultTypeInternal _OrderTree_PriceMapEntry_DoNotUse_default_instance_;
class Position;
class PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class Quote;
class QuoteDefaultTypeInternal;
extern QuoteDefaultTypeInternal _Quote_default_instance_;
class QuoteList;
class QuoteListDefaultTypeInternal;
extern QuoteListDefaultTypeInternal _QuoteList_default_instance_;
}  // namespace be
namespace google {
namespace protobuf {
template<> ::be::Empty* Arena::CreateMaybeMessage<::be::Empty>(Arena*);
template<> ::be::NumSteps* Arena::CreateMaybeMessage<::be::NumSteps>(Arena*);
template<> ::be::Order* Arena::CreateMaybeMessage<::be::Order>(Arena*);
template<> ::be::OrderBook* Arena::CreateMaybeMessage<::be::OrderBook>(Arena*);
template<> ::be::OrderBookList* Arena::CreateMaybeMessage<::be::OrderBookList>(Arena*);
template<> ::be::OrderList* Arena::CreateMaybeMessage<::be::OrderList>(Arena*);
template<> ::be::OrderTree* Arena::CreateMaybeMessage<::be::OrderTree>(Arena*);
template<> ::be::OrderTree_OrderMapEntry_DoNotUse* Arena::CreateMaybeMessage<::be::OrderTree_OrderMapEntry_DoNotUse>(Arena*);
template<> ::be::OrderTree_PriceMapEntry_DoNotUse* Arena::CreateMaybeMessage<::be::OrderTree_PriceMapEntry_DoNotUse>(Arena*);
template<> ::be::Position* Arena::CreateMaybeMessage<::be::Position>(Arena*);
template<> ::be::Quote* Arena::CreateMaybeMessage<::be::Quote>(Arena*);
template<> ::be::QuoteList* Arena::CreateMaybeMessage<::be::QuoteList>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace be {

// ===================================================================

class Empty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:be.Empty) */ {
 public:
  Empty();
  virtual ~Empty();

  Empty(const Empty& from);

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(Empty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Empty* other);
  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return CreateMaybeMessage<Empty>(NULL);
  }

  Empty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:be.Empty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Trading_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NumSteps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:be.NumSteps) */ {
 public:
  NumSteps();
  virtual ~NumSteps();

  NumSteps(const NumSteps& from);

  inline NumSteps& operator=(const NumSteps& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NumSteps(NumSteps&& from) noexcept
    : NumSteps() {
    *this = ::std::move(from);
  }

  inline NumSteps& operator=(NumSteps&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NumSteps& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NumSteps* internal_default_instance() {
    return reinterpret_cast<const NumSteps*>(
               &_NumSteps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(NumSteps* other);
  friend void swap(NumSteps& a, NumSteps& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NumSteps* New() const final {
    return CreateMaybeMessage<NumSteps>(NULL);
  }

  NumSteps* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NumSteps>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NumSteps& from);
  void MergeFrom(const NumSteps& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NumSteps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 n = 1;
  void clear_n();
  static const int kNFieldNumber = 1;
  ::google::protobuf::int32 n() const;
  void set_n(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:be.NumSteps)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 n_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Trading_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:be.Position) */ {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(Position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Position* other);
  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Position* New() const final {
    return CreateMaybeMessage<Position>(NULL);
  }

  Position* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:be.Position)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 x_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Trading_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Order : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:be.Order) */ {
 public:
  Order();
  virtual ~Order();

  Order(const Order& from);

  inline Order& operator=(const Order& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Order(Order&& from) noexcept
    : Order() {
    *this = ::std::move(from);
  }

  inline Order& operator=(Order&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Order& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Order* internal_default_instance() {
    return reinterpret_cast<const Order*>(
               &_Order_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Order* other);
  friend void swap(Order& a, Order& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Order* New() const final {
    return CreateMaybeMessage<Order>(NULL);
  }

  Order* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Order>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Order& from);
  void MergeFrom(const Order& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Order* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .be.OrderList order_list = 6;
  bool has_order_list() const;
  void clear_order_list();
  static const int kOrderListFieldNumber = 6;
  private:
  const ::be::OrderList& _internal_order_list() const;
  public:
  const ::be::OrderList& order_list() const;
  ::be::OrderList* release_order_list();
  ::be::OrderList* mutable_order_list();
  void set_allocated_order_list(::be::OrderList* order_list);

  // uint32 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // uint32 quantity = 2;
  void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  ::google::protobuf::uint32 quantity() const;
  void set_quantity(::google::protobuf::uint32 value);

  // uint64 price = 3;
  void clear_price();
  static const int kPriceFieldNumber = 3;
  ::google::protobuf::uint64 price() const;
  void set_price(::google::protobuf::uint64 value);

  // uint64 order_id = 4;
  void clear_order_id();
  static const int kOrderIdFieldNumber = 4;
  ::google::protobuf::uint64 order_id() const;
  void set_order_id(::google::protobuf::uint64 value);

  // uint32 trader_id = 5;
  void clear_trader_id();
  static const int kTraderIdFieldNumber = 5;
  ::google::protobuf::uint32 trader_id() const;
  void set_trader_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:be.Order)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::be::OrderList* order_list_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 quantity_;
  ::google::protobuf::uint64 price_;
  ::google::protobuf::uint64 order_id_;
  ::google::protobuf::uint32 trader_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Trading_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Quote : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:be.Quote) */ {
 public:
  Quote();
  virtual ~Quote();

  Quote(const Quote& from);

  inline Quote& operator=(const Quote& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quote(Quote&& from) noexcept
    : Quote() {
    *this = ::std::move(from);
  }

  inline Quote& operator=(Quote&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Quote& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quote* internal_default_instance() {
    return reinterpret_cast<const Quote*>(
               &_Quote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Quote* other);
  friend void swap(Quote& a, Quote& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quote* New() const final {
    return CreateMaybeMessage<Quote>(NULL);
  }

  Quote* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Quote>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Quote& from);
  void MergeFrom(const Quote& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quote* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes order_type = 1;
  void clear_order_type();
  static const int kOrderTypeFieldNumber = 1;
  const ::std::string& order_type() const;
  void set_order_type(const ::std::string& value);
  #if LANG_CXX11
  void set_order_type(::std::string&& value);
  #endif
  void set_order_type(const char* value);
  void set_order_type(const void* value, size_t size);
  ::std::string* mutable_order_type();
  ::std::string* release_order_type();
  void set_allocated_order_type(::std::string* order_type);

  // bytes order_side = 2;
  void clear_order_side();
  static const int kOrderSideFieldNumber = 2;
  const ::std::string& order_side() const;
  void set_order_side(const ::std::string& value);
  #if LANG_CXX11
  void set_order_side(::std::string&& value);
  #endif
  void set_order_side(const char* value);
  void set_order_side(const void* value, size_t size);
  ::std::string* mutable_order_side();
  ::std::string* release_order_side();
  void set_allocated_order_side(::std::string* order_side);

  // .be.Order order = 3;
  bool has_order() const;
  void clear_order();
  static const int kOrderFieldNumber = 3;
  private:
  const ::be::Order& _internal_order() const;
  public:
  const ::be::Order& order() const;
  ::be::Order* release_order();
  ::be::Order* mutable_order();
  void set_allocated_order(::be::Order* order);

  // @@protoc_insertion_point(class_scope:be.Quote)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr order_type_;
  ::google::protobuf::internal::ArenaStringPtr order_side_;
  ::be::Order* order_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Trading_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QuoteList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:be.QuoteList) */ {
 public:
  QuoteList();
  virtual ~QuoteList();

  QuoteList(const QuoteList& from);

  inline QuoteList& operator=(const QuoteList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QuoteList(QuoteList&& from) noexcept
    : QuoteList() {
    *this = ::std::move(from);
  }

  inline QuoteList& operator=(QuoteList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const QuoteList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QuoteList* internal_default_instance() {
    return reinterpret_cast<const QuoteList*>(
               &_QuoteList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(QuoteList* other);
  friend void swap(QuoteList& a, QuoteList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QuoteList* New() const final {
    return CreateMaybeMessage<QuoteList>(NULL);
  }

  QuoteList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QuoteList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const QuoteList& from);
  void MergeFrom(const QuoteList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuoteList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .be.Quote quotes = 1;
  int quotes_size() const;
  void clear_quotes();
  static const int kQuotesFieldNumber = 1;
  ::be::Quote* mutable_quotes(int index);
  ::google::protobuf::RepeatedPtrField< ::be::Quote >*
      mutable_quotes();
  const ::be::Quote& quotes(int index) const;
  ::be::Quote* add_quotes();
  const ::google::protobuf::RepeatedPtrField< ::be::Quote >&
      quotes() const;

  // uint64 volumn = 2;
  void clear_volumn();
  static const int kVolumnFieldNumber = 2;
  ::google::protobuf::uint64 volumn() const;
  void set_volumn(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:be.QuoteList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::be::Quote > quotes_;
  ::google::protobuf::uint64 volumn_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Trading_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OrderList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:be.OrderList) */ {
 public:
  OrderList();
  virtual ~OrderList();

  OrderList(const OrderList& from);

  inline OrderList& operator=(const OrderList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrderList(OrderList&& from) noexcept
    : OrderList() {
    *this = ::std::move(from);
  }

  inline OrderList& operator=(OrderList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderList* internal_default_instance() {
    return reinterpret_cast<const OrderList*>(
               &_OrderList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(OrderList* other);
  friend void swap(OrderList& a, OrderList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrderList* New() const final {
    return CreateMaybeMessage<OrderList>(NULL);
  }

  OrderList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OrderList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OrderList& from);
  void MergeFrom(const OrderList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .be.Order orders = 1;
  int orders_size() const;
  void clear_orders();
  static const int kOrdersFieldNumber = 1;
  ::be::Order* mutable_orders(int index);
  ::google::protobuf::RepeatedPtrField< ::be::Order >*
      mutable_orders();
  const ::be::Order& orders(int index) const;
  ::be::Order* add_orders();
  const ::google::protobuf::RepeatedPtrField< ::be::Order >&
      orders() const;

  // uint64 volumn = 2;
  void clear_volumn();
  static const int kVolumnFieldNumber = 2;
  ::google::protobuf::uint64 volumn() const;
  void set_volumn(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:be.OrderList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::be::Order > orders_;
  ::google::protobuf::uint64 volumn_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Trading_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OrderBookList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:be.OrderBookList) */ {
 public:
  OrderBookList();
  virtual ~OrderBookList();

  OrderBookList(const OrderBookList& from);

  inline OrderBookList& operator=(const OrderBookList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrderBookList(OrderBookList&& from) noexcept
    : OrderBookList() {
    *this = ::std::move(from);
  }

  inline OrderBookList& operator=(OrderBookList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderBookList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderBookList* internal_default_instance() {
    return reinterpret_cast<const OrderBookList*>(
               &_OrderBookList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(OrderBookList* other);
  friend void swap(OrderBookList& a, OrderBookList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrderBookList* New() const final {
    return CreateMaybeMessage<OrderBookList>(NULL);
  }

  OrderBookList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OrderBookList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OrderBookList& from);
  void MergeFrom(const OrderBookList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderBookList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .be.OrderBook orderbooks = 1;
  int orderbooks_size() const;
  void clear_orderbooks();
  static const int kOrderbooksFieldNumber = 1;
  ::be::OrderBook* mutable_orderbooks(int index);
  ::google::protobuf::RepeatedPtrField< ::be::OrderBook >*
      mutable_orderbooks();
  const ::be::OrderBook& orderbooks(int index) const;
  ::be::OrderBook* add_orderbooks();
  const ::google::protobuf::RepeatedPtrField< ::be::OrderBook >&
      orderbooks() const;

  // @@protoc_insertion_point(class_scope:be.OrderBookList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::be::OrderBook > orderbooks_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Trading_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OrderBook : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:be.OrderBook) */ {
 public:
  OrderBook();
  virtual ~OrderBook();

  OrderBook(const OrderBook& from);

  inline OrderBook& operator=(const OrderBook& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrderBook(OrderBook&& from) noexcept
    : OrderBook() {
    *this = ::std::move(from);
  }

  inline OrderBook& operator=(OrderBook&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderBook& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderBook* internal_default_instance() {
    return reinterpret_cast<const OrderBook*>(
               &_OrderBook_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(OrderBook* other);
  friend void swap(OrderBook& a, OrderBook& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrderBook* New() const final {
    return CreateMaybeMessage<OrderBook>(NULL);
  }

  OrderBook* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OrderBook>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OrderBook& from);
  void MergeFrom(const OrderBook& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderBook* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .be.OrderTree bid_tree = 1;
  bool has_bid_tree() const;
  void clear_bid_tree();
  static const int kBidTreeFieldNumber = 1;
  private:
  const ::be::OrderTree& _internal_bid_tree() const;
  public:
  const ::be::OrderTree& bid_tree() const;
  ::be::OrderTree* release_bid_tree();
  ::be::OrderTree* mutable_bid_tree();
  void set_allocated_bid_tree(::be::OrderTree* bid_tree);

  // .be.OrderTree ask_tree = 2;
  bool has_ask_tree() const;
  void clear_ask_tree();
  static const int kAskTreeFieldNumber = 2;
  private:
  const ::be::OrderTree& _internal_ask_tree() const;
  public:
  const ::be::OrderTree& ask_tree() const;
  ::be::OrderTree* release_ask_tree();
  ::be::OrderTree* mutable_ask_tree();
  void set_allocated_ask_tree(::be::OrderTree* ask_tree);

  // @@protoc_insertion_point(class_scope:be.OrderBook)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::be::OrderTree* bid_tree_;
  ::be::OrderTree* ask_tree_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Trading_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OrderTree_PriceMapEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<OrderTree_PriceMapEntry_DoNotUse, 
    ::google::protobuf::uint64, ::be::OrderList,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<OrderTree_PriceMapEntry_DoNotUse, 
    ::google::protobuf::uint64, ::be::OrderList,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  OrderTree_PriceMapEntry_DoNotUse();
  OrderTree_PriceMapEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const OrderTree_PriceMapEntry_DoNotUse& other);
  static const OrderTree_PriceMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const OrderTree_PriceMapEntry_DoNotUse*>(&_OrderTree_PriceMapEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class OrderTree_OrderMapEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<OrderTree_OrderMapEntry_DoNotUse, 
    ::google::protobuf::uint64, ::be::Order,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<OrderTree_OrderMapEntry_DoNotUse, 
    ::google::protobuf::uint64, ::be::Order,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  OrderTree_OrderMapEntry_DoNotUse();
  OrderTree_OrderMapEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const OrderTree_OrderMapEntry_DoNotUse& other);
  static const OrderTree_OrderMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const OrderTree_OrderMapEntry_DoNotUse*>(&_OrderTree_OrderMapEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class OrderTree : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:be.OrderTree) */ {
 public:
  OrderTree();
  virtual ~OrderTree();

  OrderTree(const OrderTree& from);

  inline OrderTree& operator=(const OrderTree& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrderTree(OrderTree&& from) noexcept
    : OrderTree() {
    *this = ::std::move(from);
  }

  inline OrderTree& operator=(OrderTree&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderTree& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderTree* internal_default_instance() {
    return reinterpret_cast<const OrderTree*>(
               &_OrderTree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(OrderTree* other);
  friend void swap(OrderTree& a, OrderTree& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrderTree* New() const final {
    return CreateMaybeMessage<OrderTree>(NULL);
  }

  OrderTree* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OrderTree>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OrderTree& from);
  void MergeFrom(const OrderTree& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderTree* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<uint64, .be.OrderList> price_map = 1;
  int price_map_size() const;
  void clear_price_map();
  static const int kPriceMapFieldNumber = 1;
  const ::google::protobuf::Map< ::google::protobuf::uint64, ::be::OrderList >&
      price_map() const;
  ::google::protobuf::Map< ::google::protobuf::uint64, ::be::OrderList >*
      mutable_price_map();

  // map<uint64, .be.Order> order_map = 2;
  int order_map_size() const;
  void clear_order_map();
  static const int kOrderMapFieldNumber = 2;
  const ::google::protobuf::Map< ::google::protobuf::uint64, ::be::Order >&
      order_map() const;
  ::google::protobuf::Map< ::google::protobuf::uint64, ::be::Order >*
      mutable_order_map();

  // uint64 volumn = 3;
  void clear_volumn();
  static const int kVolumnFieldNumber = 3;
  ::google::protobuf::uint64 volumn() const;
  void set_volumn(::google::protobuf::uint64 value);

  // uint64 min_price = 4;
  void clear_min_price();
  static const int kMinPriceFieldNumber = 4;
  ::google::protobuf::uint64 min_price() const;
  void set_min_price(::google::protobuf::uint64 value);

  // uint64 max_price = 5;
  void clear_max_price();
  static const int kMaxPriceFieldNumber = 5;
  ::google::protobuf::uint64 max_price() const;
  void set_max_price(::google::protobuf::uint64 value);

  // uint64 num_orders = 7;
  void clear_num_orders();
  static const int kNumOrdersFieldNumber = 7;
  ::google::protobuf::uint64 num_orders() const;
  void set_num_orders(::google::protobuf::uint64 value);

  // uint32 depth = 6;
  void clear_depth();
  static const int kDepthFieldNumber = 6;
  ::google::protobuf::uint32 depth() const;
  void set_depth(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:be.OrderTree)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      OrderTree_PriceMapEntry_DoNotUse,
      ::google::protobuf::uint64, ::be::OrderList,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > price_map_;
  ::google::protobuf::internal::MapField<
      OrderTree_OrderMapEntry_DoNotUse,
      ::google::protobuf::uint64, ::be::Order,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > order_map_;
  ::google::protobuf::uint64 volumn_;
  ::google::protobuf::uint64 min_price_;
  ::google::protobuf::uint64 max_price_;
  ::google::protobuf::uint64 num_orders_;
  ::google::protobuf::uint32 depth_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Trading_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Empty

// -------------------------------------------------------------------

// NumSteps

// int32 n = 1;
inline void NumSteps::clear_n() {
  n_ = 0;
}
inline ::google::protobuf::int32 NumSteps::n() const {
  // @@protoc_insertion_point(field_get:be.NumSteps.n)
  return n_;
}
inline void NumSteps::set_n(::google::protobuf::int32 value) {
  
  n_ = value;
  // @@protoc_insertion_point(field_set:be.NumSteps.n)
}

// -------------------------------------------------------------------

// Position

// int32 x = 1;
inline void Position::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 Position::x() const {
  // @@protoc_insertion_point(field_get:be.Position.x)
  return x_;
}
inline void Position::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:be.Position.x)
}

// -------------------------------------------------------------------

// Order

// uint32 timestamp = 1;
inline void Order::clear_timestamp() {
  timestamp_ = 0u;
}
inline ::google::protobuf::uint32 Order::timestamp() const {
  // @@protoc_insertion_point(field_get:be.Order.timestamp)
  return timestamp_;
}
inline void Order::set_timestamp(::google::protobuf::uint32 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:be.Order.timestamp)
}

// uint32 quantity = 2;
inline void Order::clear_quantity() {
  quantity_ = 0u;
}
inline ::google::protobuf::uint32 Order::quantity() const {
  // @@protoc_insertion_point(field_get:be.Order.quantity)
  return quantity_;
}
inline void Order::set_quantity(::google::protobuf::uint32 value) {
  
  quantity_ = value;
  // @@protoc_insertion_point(field_set:be.Order.quantity)
}

// uint64 price = 3;
inline void Order::clear_price() {
  price_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Order::price() const {
  // @@protoc_insertion_point(field_get:be.Order.price)
  return price_;
}
inline void Order::set_price(::google::protobuf::uint64 value) {
  
  price_ = value;
  // @@protoc_insertion_point(field_set:be.Order.price)
}

// uint64 order_id = 4;
inline void Order::clear_order_id() {
  order_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Order::order_id() const {
  // @@protoc_insertion_point(field_get:be.Order.order_id)
  return order_id_;
}
inline void Order::set_order_id(::google::protobuf::uint64 value) {
  
  order_id_ = value;
  // @@protoc_insertion_point(field_set:be.Order.order_id)
}

// uint32 trader_id = 5;
inline void Order::clear_trader_id() {
  trader_id_ = 0u;
}
inline ::google::protobuf::uint32 Order::trader_id() const {
  // @@protoc_insertion_point(field_get:be.Order.trader_id)
  return trader_id_;
}
inline void Order::set_trader_id(::google::protobuf::uint32 value) {
  
  trader_id_ = value;
  // @@protoc_insertion_point(field_set:be.Order.trader_id)
}

// .be.OrderList order_list = 6;
inline bool Order::has_order_list() const {
  return this != internal_default_instance() && order_list_ != NULL;
}
inline void Order::clear_order_list() {
  if (GetArenaNoVirtual() == NULL && order_list_ != NULL) {
    delete order_list_;
  }
  order_list_ = NULL;
}
inline const ::be::OrderList& Order::_internal_order_list() const {
  return *order_list_;
}
inline const ::be::OrderList& Order::order_list() const {
  const ::be::OrderList* p = order_list_;
  // @@protoc_insertion_point(field_get:be.Order.order_list)
  return p != NULL ? *p : *reinterpret_cast<const ::be::OrderList*>(
      &::be::_OrderList_default_instance_);
}
inline ::be::OrderList* Order::release_order_list() {
  // @@protoc_insertion_point(field_release:be.Order.order_list)
  
  ::be::OrderList* temp = order_list_;
  order_list_ = NULL;
  return temp;
}
inline ::be::OrderList* Order::mutable_order_list() {
  
  if (order_list_ == NULL) {
    auto* p = CreateMaybeMessage<::be::OrderList>(GetArenaNoVirtual());
    order_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:be.Order.order_list)
  return order_list_;
}
inline void Order::set_allocated_order_list(::be::OrderList* order_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete order_list_;
  }
  if (order_list) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      order_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, order_list, submessage_arena);
    }
    
  } else {
    
  }
  order_list_ = order_list;
  // @@protoc_insertion_point(field_set_allocated:be.Order.order_list)
}

// -------------------------------------------------------------------

// Quote

// bytes order_type = 1;
inline void Quote::clear_order_type() {
  order_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Quote::order_type() const {
  // @@protoc_insertion_point(field_get:be.Quote.order_type)
  return order_type_.GetNoArena();
}
inline void Quote::set_order_type(const ::std::string& value) {
  
  order_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:be.Quote.order_type)
}
#if LANG_CXX11
inline void Quote::set_order_type(::std::string&& value) {
  
  order_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:be.Quote.order_type)
}
#endif
inline void Quote::set_order_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  order_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:be.Quote.order_type)
}
inline void Quote::set_order_type(const void* value, size_t size) {
  
  order_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:be.Quote.order_type)
}
inline ::std::string* Quote::mutable_order_type() {
  
  // @@protoc_insertion_point(field_mutable:be.Quote.order_type)
  return order_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Quote::release_order_type() {
  // @@protoc_insertion_point(field_release:be.Quote.order_type)
  
  return order_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Quote::set_allocated_order_type(::std::string* order_type) {
  if (order_type != NULL) {
    
  } else {
    
  }
  order_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), order_type);
  // @@protoc_insertion_point(field_set_allocated:be.Quote.order_type)
}

// bytes order_side = 2;
inline void Quote::clear_order_side() {
  order_side_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Quote::order_side() const {
  // @@protoc_insertion_point(field_get:be.Quote.order_side)
  return order_side_.GetNoArena();
}
inline void Quote::set_order_side(const ::std::string& value) {
  
  order_side_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:be.Quote.order_side)
}
#if LANG_CXX11
inline void Quote::set_order_side(::std::string&& value) {
  
  order_side_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:be.Quote.order_side)
}
#endif
inline void Quote::set_order_side(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  order_side_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:be.Quote.order_side)
}
inline void Quote::set_order_side(const void* value, size_t size) {
  
  order_side_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:be.Quote.order_side)
}
inline ::std::string* Quote::mutable_order_side() {
  
  // @@protoc_insertion_point(field_mutable:be.Quote.order_side)
  return order_side_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Quote::release_order_side() {
  // @@protoc_insertion_point(field_release:be.Quote.order_side)
  
  return order_side_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Quote::set_allocated_order_side(::std::string* order_side) {
  if (order_side != NULL) {
    
  } else {
    
  }
  order_side_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), order_side);
  // @@protoc_insertion_point(field_set_allocated:be.Quote.order_side)
}

// .be.Order order = 3;
inline bool Quote::has_order() const {
  return this != internal_default_instance() && order_ != NULL;
}
inline void Quote::clear_order() {
  if (GetArenaNoVirtual() == NULL && order_ != NULL) {
    delete order_;
  }
  order_ = NULL;
}
inline const ::be::Order& Quote::_internal_order() const {
  return *order_;
}
inline const ::be::Order& Quote::order() const {
  const ::be::Order* p = order_;
  // @@protoc_insertion_point(field_get:be.Quote.order)
  return p != NULL ? *p : *reinterpret_cast<const ::be::Order*>(
      &::be::_Order_default_instance_);
}
inline ::be::Order* Quote::release_order() {
  // @@protoc_insertion_point(field_release:be.Quote.order)
  
  ::be::Order* temp = order_;
  order_ = NULL;
  return temp;
}
inline ::be::Order* Quote::mutable_order() {
  
  if (order_ == NULL) {
    auto* p = CreateMaybeMessage<::be::Order>(GetArenaNoVirtual());
    order_ = p;
  }
  // @@protoc_insertion_point(field_mutable:be.Quote.order)
  return order_;
}
inline void Quote::set_allocated_order(::be::Order* order) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete order_;
  }
  if (order) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      order = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    
  } else {
    
  }
  order_ = order;
  // @@protoc_insertion_point(field_set_allocated:be.Quote.order)
}

// -------------------------------------------------------------------

// QuoteList

// repeated .be.Quote quotes = 1;
inline int QuoteList::quotes_size() const {
  return quotes_.size();
}
inline void QuoteList::clear_quotes() {
  quotes_.Clear();
}
inline ::be::Quote* QuoteList::mutable_quotes(int index) {
  // @@protoc_insertion_point(field_mutable:be.QuoteList.quotes)
  return quotes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::be::Quote >*
QuoteList::mutable_quotes() {
  // @@protoc_insertion_point(field_mutable_list:be.QuoteList.quotes)
  return &quotes_;
}
inline const ::be::Quote& QuoteList::quotes(int index) const {
  // @@protoc_insertion_point(field_get:be.QuoteList.quotes)
  return quotes_.Get(index);
}
inline ::be::Quote* QuoteList::add_quotes() {
  // @@protoc_insertion_point(field_add:be.QuoteList.quotes)
  return quotes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::be::Quote >&
QuoteList::quotes() const {
  // @@protoc_insertion_point(field_list:be.QuoteList.quotes)
  return quotes_;
}

// uint64 volumn = 2;
inline void QuoteList::clear_volumn() {
  volumn_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 QuoteList::volumn() const {
  // @@protoc_insertion_point(field_get:be.QuoteList.volumn)
  return volumn_;
}
inline void QuoteList::set_volumn(::google::protobuf::uint64 value) {
  
  volumn_ = value;
  // @@protoc_insertion_point(field_set:be.QuoteList.volumn)
}

// -------------------------------------------------------------------

// OrderList

// repeated .be.Order orders = 1;
inline int OrderList::orders_size() const {
  return orders_.size();
}
inline void OrderList::clear_orders() {
  orders_.Clear();
}
inline ::be::Order* OrderList::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:be.OrderList.orders)
  return orders_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::be::Order >*
OrderList::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:be.OrderList.orders)
  return &orders_;
}
inline const ::be::Order& OrderList::orders(int index) const {
  // @@protoc_insertion_point(field_get:be.OrderList.orders)
  return orders_.Get(index);
}
inline ::be::Order* OrderList::add_orders() {
  // @@protoc_insertion_point(field_add:be.OrderList.orders)
  return orders_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::be::Order >&
OrderList::orders() const {
  // @@protoc_insertion_point(field_list:be.OrderList.orders)
  return orders_;
}

// uint64 volumn = 2;
inline void OrderList::clear_volumn() {
  volumn_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 OrderList::volumn() const {
  // @@protoc_insertion_point(field_get:be.OrderList.volumn)
  return volumn_;
}
inline void OrderList::set_volumn(::google::protobuf::uint64 value) {
  
  volumn_ = value;
  // @@protoc_insertion_point(field_set:be.OrderList.volumn)
}

// -------------------------------------------------------------------

// OrderBookList

// repeated .be.OrderBook orderbooks = 1;
inline int OrderBookList::orderbooks_size() const {
  return orderbooks_.size();
}
inline void OrderBookList::clear_orderbooks() {
  orderbooks_.Clear();
}
inline ::be::OrderBook* OrderBookList::mutable_orderbooks(int index) {
  // @@protoc_insertion_point(field_mutable:be.OrderBookList.orderbooks)
  return orderbooks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::be::OrderBook >*
OrderBookList::mutable_orderbooks() {
  // @@protoc_insertion_point(field_mutable_list:be.OrderBookList.orderbooks)
  return &orderbooks_;
}
inline const ::be::OrderBook& OrderBookList::orderbooks(int index) const {
  // @@protoc_insertion_point(field_get:be.OrderBookList.orderbooks)
  return orderbooks_.Get(index);
}
inline ::be::OrderBook* OrderBookList::add_orderbooks() {
  // @@protoc_insertion_point(field_add:be.OrderBookList.orderbooks)
  return orderbooks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::be::OrderBook >&
OrderBookList::orderbooks() const {
  // @@protoc_insertion_point(field_list:be.OrderBookList.orderbooks)
  return orderbooks_;
}

// -------------------------------------------------------------------

// OrderBook

// .be.OrderTree bid_tree = 1;
inline bool OrderBook::has_bid_tree() const {
  return this != internal_default_instance() && bid_tree_ != NULL;
}
inline void OrderBook::clear_bid_tree() {
  if (GetArenaNoVirtual() == NULL && bid_tree_ != NULL) {
    delete bid_tree_;
  }
  bid_tree_ = NULL;
}
inline const ::be::OrderTree& OrderBook::_internal_bid_tree() const {
  return *bid_tree_;
}
inline const ::be::OrderTree& OrderBook::bid_tree() const {
  const ::be::OrderTree* p = bid_tree_;
  // @@protoc_insertion_point(field_get:be.OrderBook.bid_tree)
  return p != NULL ? *p : *reinterpret_cast<const ::be::OrderTree*>(
      &::be::_OrderTree_default_instance_);
}
inline ::be::OrderTree* OrderBook::release_bid_tree() {
  // @@protoc_insertion_point(field_release:be.OrderBook.bid_tree)
  
  ::be::OrderTree* temp = bid_tree_;
  bid_tree_ = NULL;
  return temp;
}
inline ::be::OrderTree* OrderBook::mutable_bid_tree() {
  
  if (bid_tree_ == NULL) {
    auto* p = CreateMaybeMessage<::be::OrderTree>(GetArenaNoVirtual());
    bid_tree_ = p;
  }
  // @@protoc_insertion_point(field_mutable:be.OrderBook.bid_tree)
  return bid_tree_;
}
inline void OrderBook::set_allocated_bid_tree(::be::OrderTree* bid_tree) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bid_tree_;
  }
  if (bid_tree) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bid_tree = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bid_tree, submessage_arena);
    }
    
  } else {
    
  }
  bid_tree_ = bid_tree;
  // @@protoc_insertion_point(field_set_allocated:be.OrderBook.bid_tree)
}

// .be.OrderTree ask_tree = 2;
inline bool OrderBook::has_ask_tree() const {
  return this != internal_default_instance() && ask_tree_ != NULL;
}
inline void OrderBook::clear_ask_tree() {
  if (GetArenaNoVirtual() == NULL && ask_tree_ != NULL) {
    delete ask_tree_;
  }
  ask_tree_ = NULL;
}
inline const ::be::OrderTree& OrderBook::_internal_ask_tree() const {
  return *ask_tree_;
}
inline const ::be::OrderTree& OrderBook::ask_tree() const {
  const ::be::OrderTree* p = ask_tree_;
  // @@protoc_insertion_point(field_get:be.OrderBook.ask_tree)
  return p != NULL ? *p : *reinterpret_cast<const ::be::OrderTree*>(
      &::be::_OrderTree_default_instance_);
}
inline ::be::OrderTree* OrderBook::release_ask_tree() {
  // @@protoc_insertion_point(field_release:be.OrderBook.ask_tree)
  
  ::be::OrderTree* temp = ask_tree_;
  ask_tree_ = NULL;
  return temp;
}
inline ::be::OrderTree* OrderBook::mutable_ask_tree() {
  
  if (ask_tree_ == NULL) {
    auto* p = CreateMaybeMessage<::be::OrderTree>(GetArenaNoVirtual());
    ask_tree_ = p;
  }
  // @@protoc_insertion_point(field_mutable:be.OrderBook.ask_tree)
  return ask_tree_;
}
inline void OrderBook::set_allocated_ask_tree(::be::OrderTree* ask_tree) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ask_tree_;
  }
  if (ask_tree) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ask_tree = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ask_tree, submessage_arena);
    }
    
  } else {
    
  }
  ask_tree_ = ask_tree;
  // @@protoc_insertion_point(field_set_allocated:be.OrderBook.ask_tree)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// OrderTree

// map<uint64, .be.OrderList> price_map = 1;
inline int OrderTree::price_map_size() const {
  return price_map_.size();
}
inline void OrderTree::clear_price_map() {
  price_map_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint64, ::be::OrderList >&
OrderTree::price_map() const {
  // @@protoc_insertion_point(field_map:be.OrderTree.price_map)
  return price_map_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint64, ::be::OrderList >*
OrderTree::mutable_price_map() {
  // @@protoc_insertion_point(field_mutable_map:be.OrderTree.price_map)
  return price_map_.MutableMap();
}

// map<uint64, .be.Order> order_map = 2;
inline int OrderTree::order_map_size() const {
  return order_map_.size();
}
inline void OrderTree::clear_order_map() {
  order_map_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint64, ::be::Order >&
OrderTree::order_map() const {
  // @@protoc_insertion_point(field_map:be.OrderTree.order_map)
  return order_map_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint64, ::be::Order >*
OrderTree::mutable_order_map() {
  // @@protoc_insertion_point(field_mutable_map:be.OrderTree.order_map)
  return order_map_.MutableMap();
}

// uint64 volumn = 3;
inline void OrderTree::clear_volumn() {
  volumn_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 OrderTree::volumn() const {
  // @@protoc_insertion_point(field_get:be.OrderTree.volumn)
  return volumn_;
}
inline void OrderTree::set_volumn(::google::protobuf::uint64 value) {
  
  volumn_ = value;
  // @@protoc_insertion_point(field_set:be.OrderTree.volumn)
}

// uint64 min_price = 4;
inline void OrderTree::clear_min_price() {
  min_price_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 OrderTree::min_price() const {
  // @@protoc_insertion_point(field_get:be.OrderTree.min_price)
  return min_price_;
}
inline void OrderTree::set_min_price(::google::protobuf::uint64 value) {
  
  min_price_ = value;
  // @@protoc_insertion_point(field_set:be.OrderTree.min_price)
}

// uint64 max_price = 5;
inline void OrderTree::clear_max_price() {
  max_price_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 OrderTree::max_price() const {
  // @@protoc_insertion_point(field_get:be.OrderTree.max_price)
  return max_price_;
}
inline void OrderTree::set_max_price(::google::protobuf::uint64 value) {
  
  max_price_ = value;
  // @@protoc_insertion_point(field_set:be.OrderTree.max_price)
}

// uint64 num_orders = 7;
inline void OrderTree::clear_num_orders() {
  num_orders_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 OrderTree::num_orders() const {
  // @@protoc_insertion_point(field_get:be.OrderTree.num_orders)
  return num_orders_;
}
inline void OrderTree::set_num_orders(::google::protobuf::uint64 value) {
  
  num_orders_ = value;
  // @@protoc_insertion_point(field_set:be.OrderTree.num_orders)
}

// uint32 depth = 6;
inline void OrderTree::clear_depth() {
  depth_ = 0u;
}
inline ::google::protobuf::uint32 OrderTree::depth() const {
  // @@protoc_insertion_point(field_get:be.OrderTree.depth)
  return depth_;
}
inline void OrderTree::set_depth(::google::protobuf::uint32 value) {
  
  depth_ = value;
  // @@protoc_insertion_point(field_set:be.OrderTree.depth)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace be

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Trading_2eproto
